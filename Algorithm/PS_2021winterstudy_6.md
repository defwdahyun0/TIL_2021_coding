## MST : 신장트리(Spanning tree) 
문제유형, 자료구조

* 신장트리(Spanning Tree)란
    * 1) 원 그래프의 모든 노드를 포함하고
    * 2) 모든 노드가 서로 연결되어 있으면서
    * 3) 트리(Tree)의 속성을 만족하는 그래프
트리는 Cycle이 없는 그래프. 당연히 Cycle이 없어야하는 것

## MST : 최소신장트리(Minimum Spanning tree)
* 최소신장트리(MST)는 
    * 가능한 신장트리 가운데 edge weight의 합이 최소인 신장트리

* 좌측 그래프의 MST는 화살표로 연결된 우측 그래프

## MST : 최소 신장트리 구하는 방법?
* 
    * 최단거리는 다익스트라를 통해서 구할 수 있음
        * 최단거리 is not MST

* 최소신장트리는 아래 두 기법을 사용
    * 크루스칼 알고리즘
            O(ElogV)
    * 프림 알고리즘
            O(V+ElogV)

*면접* 섣불리 답을 내려서는 안됨

프림은 빽빽한 그래프, 크루스칼은 넓은 그래프에서 더 빠른 결과가 있다.
어떤 것이 더 좋아보이는, 두괄식 대답보다도, 어떤 상황에서 정확할지 먼저 말하고 크루스칼이 더 좋다고 말을 하면 좋을 것 같다.

* 최소신장트리(MST) 구하는 방법?
    * (문제풀 때는)그냥 둘다 동일 선상에 두고 써도 됨
    * 개인적으로는 kruskal이 빠르고(큰 차이는 아니다)
    * Prim이 구현하기는 쉽다

어느정도가 Dense?Sparse? 달라지는 부분이 많다. 하지만 큰 차이는 아니다.

### 예시문제 - 1197번, 최소 스패닝 트리

최소스패닝트리를 구해서 가중치를 출력하는 문제이다.
E = V-1

## 1197번 두 가지 풀이 방법 - 이 페이지 정말 중요!!!
크루스칼 알고리즘 - 가중치가 최소인 간선을 하나씩 선택
프림 알고리즘 - 정점을 선택

크루스칼 알고리즘 - 가중치가 최소인 간선을 선택하여 MST 구성

구현할 때는 Union-Find 연산을 활용, 중요

과정을 설명하면 다음과 같은 과정을 반복
* 1. 모든 간선을 가중치에 따라 오름차순 정렬
* 2. 가중치가 가장 낮은 간선부터 차례대로 선택하면서 트리 구성
* 3. 만약 간선을 선택했을 때, 사이클이 존재하면 다음 간선으로 이동(무시)
* 4. ...

1194번 크루스칼 풀이 방법
체크가 된 노드를 또 체크하는 것은 불필요한 작업
MST 트리라는 자료구조의 특성이 사이클을 피해가는 과정

사이클이 존재했을 때 다음으로 건너뛴다.
35는 체크가 되고 체크했을 때 N-1개의 간선이 나와서 MST를 표시하고 ...

Union Find 과제...... 사이클을 찾기 위한 방법

사이클이 없으면 union해주고 sum을 추가해주자.
lonlong이 아니라 int를 쓰면 출력추가
quenqur는 unionfind에서 쓰지 않고, c++에서는 union 공용체랑 겹쳐서 dvd qq


1197번 프림 풀이 방법
* 연결된 정점에서 다른 MST를 만들어가는 방식
구현하기 쉬워서 추천
* BFS,다익스트라랑 비슷, 상대적으로 구현하기 쉬움
* 과정을 설명하면 

....

1번에서 시작 갈 수 있는 경로 중에 
갈 수 있는 간선들에서 가장 짧은 경로
min heap
push가 되어있는 순서에서 자동으로 가져오기
minheap, 다익스트라랑도 비슷

사이클을 구현할 때 visited() 배열 사용하면 사이클 무시할 수 있어서 구현하기 쉬움

## 프림 풀이
main (둘 다 넣어주고)
prim();
정답

prim() 
임의의 점, 초기화,  push해주고 첫번째를 pop 갈 수 있는 경로 4개 배제.
이미 들렸어? 그러면 minheap에 노드 자체를 넣어줌
다음 노드가 어디냐
갈 수 있는 노드 선택하고 선택할 경로를 pop
visited? 
다익스트라 2가지 weight,next
weight를 먼저 넣지 않으면 웨이트 기준으로 보게끔 되어 있는데 node먼저를 넣으면 순서가 꼬임
min_heap 사용할 때 꼭 weight에 해당하는 변수 선언

길게 나오면 좋지 않

프림은 바이다이렉션, 다이렉션이 있다고 표현하면 다이렉션에 따라서만 가지만
크루스칼은 다이렉션이 있든 없든 상관이 없다. 간선을 중심으로 보기 때문에 간선 선택했으면 1,2 자동으로 선택해서 어느쪽이든 상관이 없음.
크루스칼에서 사이클은 방향이 어떻게 되든 그것 자체가 사이클

크루스칼은 다이렉션에 대해서 굳이 표현할 필요는 없다.

경험상 크루스칼이 더 빠르지만 근소한 차이
크루스칼이 빠른 대신에 프림이 구현하기는 쉬움

정리! 스패닝 트리에 vertex 연결이 되었을 때 최소의 간선으로 연결되는 모양. 여러 방법이 있는데 weight의 합이 MST, 크루스칼/프림 알고리즘 

union&find 연산에서 nlogn.
프림은 priority que
두 방법 비교